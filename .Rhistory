A,
20,
10^-10,
y,
yIndices)
t0
t1$derivative
t1$logLike
sum(t1$test)
res_ad=optim(params,ll_wrapper,ll_deriv,
X_intercept,
coords,
neighborMatrix,
steps,
tol,
y,
yIndices,
method="BFGS",
control=list(fnscale=-1))
res_ad
t1=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
t0
t1$derivative
t1$logLike
sum(t1$test)
t0=gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE)
t1=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
t0
t1$derivative
t1$logLike
sum(t1$test)
t1=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
library(implicit)
t1=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
setwd("C:/Dropbox/CWD/cwd_covariates/")
load("Data/analysisCovariates.RData")
source("../cwdCode/R/kolmogorov.R")
library(sp)
library(ggplot2)
params=c(-5,-6,c(-91,44.,log(2),log(10)))
X_intercept=X[,1,drop=FALSE]
KF=TRUE
steps=20
tol=10^-6
coords=coordinates(longLats)
neighborMatrix=A
# Rcpp::List logLikelihood_ad(Eigen::VectorXd params,
#                             Eigen::MatrixXd X,
#                             Eigen::MatrixXd initCov,
#                             Eigen::SparseMatrix<double> neighborMatrix,
#                             int timeSteps,
#                             double tol,
#                             Eigen::VectorXi y,
#                             Eigen::VectorXi yIndices){
val=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
ll_wrapper<-function(params,
X_intercept,
coords,
A,
timeSteps,
tol,
y,
yIndices){
val=logLikelihood_ad(params,
X_intercept,
coords,
A,
timeSteps,
tol,
y,
yIndices)
print(val$logLike)
return(val$logLike)
}
ll_deriv<-function(params,
X_intercept,
coords,
A,
steps,
tol,
y,
yIndices){
val=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-6,
y,
yIndices)
return(val$derivative)
}
logLikelihood(params,
X_intercept,
coords,
neighborMatrix,
steps,
KF,
y,
yIndices,
tol,
"simple",
TRUE)
gradFunc<-function(params,X,X_spline,neighborMatrix,steps,KF,y,yIndices,tol,method="simple",kernel){
val=numDeriv::grad(func=logLikelihood,params,method=method,side=NULL,method.args=list(eps=10^-4),X,X_spline,neighborMatrix,steps,KF,y,yIndices,tol,method,kernel)
return(val)
}
t0=gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE)
t1=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
t0
t1$derivative
t1$logLike
sum(t1$test)
t0=gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE)
t1=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
t0
t1
t0=gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE)
t1=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
microbenchmark::microbenchmark(logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices),times=20)
microbenchmark::microbenchmark(gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE),times=20)
library(implicit)
microbenchmark::microbenchmark(gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE),times=20)
microbenchmark::microbenchmark(gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE),times=20)
microbenchmark::microbenchmark(logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices),times=20)
microbenchmark::microbenchmark(logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices),times=20)
res_ad=optim(params,ll_wrapper,ll_deriv,
X_intercept,
coords,
neighborMatrix,
steps,
tol,
y,
yIndices,
method="BFGS",
control=list(fnscale=-1))
res_ad
res_ad
source('C:/Dropbox/CWD/cwdCode/R/kfAnalysis.R', echo=TRUE)
source('C:/Dropbox/CWD/cwdCode/R/kfAnalysis.R', echo=TRUE)
params1=res_ad$par
logLikelihood(params1,
X_intercept,
coords,
neighborMatrix,
steps,
KF,
y,
yIndices,
tol,
"simple",
TRUE)
t1=logLikelihood_ad(params1,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
t1
t1$logLike
t1$diffusion
anyNA(t1$diffusion)
anyNA.numeric_version(t1$diffusion)
library(implicit)
res_ad=optim(params,ll_wrapper,ll_deriv,
X_intercept,
coords,
neighborMatrix,
steps,
tol,
y,
yIndices,
method="BFGS",
control=list(fnscale=-1))
res_io_KF=optim(par=params,fn=logLikelihood,gr=gradFunc,
X_intercept,
coords,
neighborMatrix,
steps,
KF,
y,
yIndices,
tol,
"simple",
TRUE,
method="BFGS",control=list(fnscale=-1,
trace=1,
REPORT=1,
reltol=10^-16,
maxit=200))
res_ad=optim(params,ll_wrapper,ll_deriv,
X_intercept,
coords,
neighborMatrix,
steps,
tol,
y,
yIndices,
method="BFGS",
control=list(fnscale=-1))
res_io_KF=optim(par=params,fn=logLikelihood,gr=gradFunc,
X_intercept,
coords,
neighborMatrix,
steps,
KF,
y,
yIndices,
tol,
"simple",
TRUE,
method="BFGS",control=list(fnscale=-1,
trace=1,
REPORT=1,
reltol=10^-16,
maxit=200))
params=c(-5,-5,c(-91,44.,log(2),log(10)))
X_intercept=X[,1,drop=FALSE]
KF=TRUE
steps=20
tol=10^-6
coords=coordinates(longLats)
neighborMatrix=A
# Rcpp::List logLikelihood_ad(Eigen::VectorXd params,
#                             Eigen::MatrixXd X,
#                             Eigen::MatrixXd initCov,
#                             Eigen::SparseMatrix<double> neighborMatrix,
#                             int timeSteps,
#                             double tol,
#                             Eigen::VectorXi y,
#                             Eigen::VectorXi yIndices){
val=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
ll_wrapper<-function(params,
X_intercept,
coords,
A,
timeSteps,
tol,
y,
yIndices){
val=logLikelihood_ad(params,
X_intercept,
coords,
A,
timeSteps,
tol,
y,
yIndices)
print(val$logLike)
return(val$logLike)
}
ll_deriv<-function(params,
X_intercept,
coords,
A,
steps,
tol,
y,
yIndices){
val=logLikelihood_ad(params,
X_intercept,
coords,
A,
20,
10^-6,
y,
yIndices)
print(val$derivative)
print(params)
return(val$derivative)
}
logLikelihood(params,
X_intercept,
coords,
neighborMatrix,
steps,
KF,
y,
yIndices,
tol,
"simple",
TRUE)
gradFunc<-function(params,X,X_spline,neighborMatrix,steps,KF,y,yIndices,tol,method="simple",kernel){
val=numDeriv::grad(func=logLikelihood,params,method=method,side=NULL,method.args=list(eps=10^-4),X,X_spline,neighborMatrix,steps,KF,y,yIndices,tol,method,kernel)
return(val)
}
t0=gradFunc(params,
X_intercept,
coords,
A,
20,
TRUE,
y,
yIndices,
tol,
"simple",
TRUE)
t1=logLikelihood_ad(params1,
X_intercept,
coords,
A,
20,
10^-10,
y,
yIndices)
t0
t1$derivative
t1$logLike
sum(t1$test)
res_ad=optim(params,ll_wrapper,ll_deriv,
X_intercept,
coords,
neighborMatrix,
steps,
tol,
y,
yIndices,
method="BFGS",
control=list(fnscale=-1))
params1=res_ad$par
logLikelihood(params1,
X_intercept,
coords,
neighborMatrix,
steps,
KF,
y,
yIndices,
tol,
"simple",
TRUE)
res_io_KF=optim(par=params,fn=logLikelihood,gr=gradFunc,
X_intercept,
coords,
neighborMatrix,
steps,
KF,
y,
yIndices,
tol,
"simple",
TRUE,
method="BFGS",control=list(fnscale=-1,
trace=1,
REPORT=1,
reltol=10^-16,
maxit=200))
qnorm(0.95,mean=1,sd=1/8)
0.38/(0.25/22)^0.5
0.38/0.1066
pnorm(3.564728)
1-pnorm(3.564728)
2*(1-pnorm(3.564728))
library(implicit)
library(implicit)
devtools::build()
